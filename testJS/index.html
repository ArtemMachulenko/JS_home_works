<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Test JS</title>
</head>
<body>

<script>
    //1) Типы данных в JS
    //Вiдповiдь: string, number, boolean, object, null, undefined, symbol
    //------------------------------
    //2) Що таке ES
        //a) Стандарт яким користуэться JS
        //b) Один iз способiв обробки асинхронностi
        //c)Спосiб наслiдування класiв
    //Вiдповiдь: a
    //------------------------------
    //3) Назвати всi методи массивiв якi ви знаэте
    //Вiдповiдь:
    //pop
    //push
    //shift
    //unshift
    //forEach
    //map
    //filter
    //find
    //every
    //some
    //reduce
    //includes
    //indexOf
    //concat
    //slice
    //splice
    //reverse
    //fill
    //sort
    //flat
    //-------------------------------
    //4)JSON - це
        //a) Java Script Object Notation
        //b) Java Script Object Notification
        //c) Java Script Object Navigation
    //Вiдповiдь: a
    //-------------------------------
    //5) Напишть counter на замиканнях
    const makeCounter = () => {
        let count = 0;

        return () => count++;
    }

    const counter1 = makeCounter();
    console.log(counter1()); //0
    console.log(counter1()); //1
    console.log(counter1()); //2

    console.log('------------------------');
    //-------------------------------
    //6) Переберiть массив за допомогою колбекiв. БЕЗ ЦИКЛIВ.
    const arr = [1,2,3,4,5,6];

    const rec = (array, index) => {
        if (index >= array.length ) return;
        console.log(array[index]);
        index++;
        rec(array, index)
    }

    rec(arr, 0); //1,2,3,4,5,6
    //------------------------------
    //7) Що таке arguments? Чи можна передрати його циклом forEach?

    // arguments - це псевдомассив аргументiв з якими була викликана функцiя
    // щоб була можливiсть перебрати його циклом forEach, треба перетворити його в массив:
    // 1) оператором spread:
    // const arr = [...arguments];
    // 2) вызвать метод массивов slice в контексте arguments
    // const arr = [].slice.call(arguments);
    //-----------------------------
    //8) Що таке Hoisting?

    //Можливiсть функцii, яка обявлена як Function Declaration бути визваною перед нею.
    //-----------------------------
    //9) Cтрiлочнi функцii. Рiзниця з простими функцiями.

    //стрiлочнi функцii не мають свого this  i arguments, мають коротший синтаксис.
    //-----------------------------
    //10) Що таке Promise. Якi вiн мае стани.

    //Метод обекта Window, який використовуэться для обробки асинхронного коду,
    // або для рiшення проблеми адськоi пiрамiди коллбекiв.
    //Мае стани pending i resolved.
    //-----------------------------
    //11) Що таке Curring

    //Можливiсть викликати функцiю з аргументами як згрупповано f(1,2,3); так i поокремо f(1)(2)(3);
    //----------------------------
    //12) На що ссилаеться this.

    //Якщо this знаходиться в лiтералi обекта, вiн ссилаеться на цей обект.
    //Якщо this знаходиться в функцii i вона буде просто викликана, то this ссилаеться на обект Window,
    //а в use strict буде undefined
    //Якщо this знаходиться в функцii i вона буде викликана за допомогою call/applу в контекстi якогось обекта
    //то this буде ссилатись на цей обект.
    //Якщо функцiя буде привязана до якогось обекта за допомогою bind, то this буде ссилатись на цей обект.
    //Якщо this знаходиться в функцii-конструкторi або в конструкторi class, то this буде ссилатись на екземпляр классу.
    //----------------------------
    //13) Все що ви знаете про Object.assign.

    // Метод призначений для обеднання обектiв
    // Основним буде той обект який буде першим аргументом, властивостi другого будуть скопiйованi в нього
    // Якщо обекти будуть мати однаковi ключi, то значенням першого перезапишеться значенням з другого (мутуе)
    // В основному першим аргументом використовують пустий обект
    //---------------------------
    //14) Прототип. Плюси i мiнуси
    //Щоб iснуючий обект1 мав властивостi i методи обекта2, можна зробити обект2 прототипом обекта1,
    //за допомогою метода Object.setPrototypeOf(обект1,обект2)
    //Щоб новостворений обект1 мав прототипом обект2 використовуем обект1 = Object.create(обект2)
    //--------------------------
    //15) Все шо знаете про ООП

    //ООП - спосiб органiзацii коду де, замicть створення глобальних змiнних i функцiй якi викликають
    //одна одну, створюеться едина сутнicть, яка мае в собi властивостшi i методи.
    //Код органiзований способом OOП легше розробляти i вiн стае розширюваним.
    //обекти створюються за допомогою функцiй конструкторiв (ES6 - classes)
    //iнкапсуляцiя - коли обект мае iзольованi властивостi i методи назва яких починаеться з _,
    //вони використовуються тiльки всерединi конструктора.
    //статика - функцiя конструктор може мати статичнi властивостi i методи,
    //вони використовуються коли е якicь дii не повязанi з екземпляром класу.
    //для перевiрок установлення значення властивостi, можна використовувати метод setter для отримання getter
    //конструктор може наслiдувати властивостi i методи вiд iншого констуктора за допомого extends,
    //та визова super() в constructor().
    //унаслiдованi методи можна переопрiделяти, або розширювати викликаючи унаслiдуваний метод в свому методi
    //за допомогою super()

    class Animal {
        constructor(name) {
            this.name = name;
        }

        walk() {
            console.log(`I walk!`);
        }

        static getTime() {
            console.log(new Date().toLocaleTimeString());
        }
    }


    class Cat extends Animal {
        constructor(name,age) {
            super(name);
            this.age = age;
        }

        jump() {
            console.log(`I jump!`);
        }

        walk() {
            super.walk();
            this.jump();
            Animal.getTime();
        }
    }

    const cat1 = new Cat('Vasya', 12);
    cat1.walk();

</script>
</body>
</html>